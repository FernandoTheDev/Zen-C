fn test_slice_return_fn() {
    let s = [1.0, 2.0, 3.0]
    assert(s[0] == 1.0, "slice[0] != 1.0");
    assert(s[1] == 2.0, "slice[1] != 2.0");
    assert(s[2] == 3.0, "slice[2] != 3.0");
}

fn test_float_slice_return_fn() -> [float] {
    // implicit cast from double to float
    return [1.0, 2.0, 3.0]
}

fn test_double_slice_return_fn() -> [double] {
    return [4.0, 5.0, 6.0]
}

test "slice_literal_return_heap_allocation" {
    test_slice_return_fn();
}

test "slice_literal_return_mixed_types" {
    let f = test_float_slice_return_fn();
    assert(f[0] >= 0.9 && f[0] <= 1.1, "float slice[0] wrong");
    assert(f[1] >= 1.9 && f[1] <= 2.1, "float slice[1] wrong");
    assert(f[2] >= 2.9 && f[2] <= 3.1, "float slice[2] wrong");
}

test "slice_literal_return_double" {
    let d = test_double_slice_return_fn();
    assert(d[0] == 4.0, "double slice[0] wrong");
    assert(d[1] == 5.0, "double slice[1] wrong");
    assert(d[2] == 6.0, "double slice[2] wrong");
}

test "empty_slice_return" {
    let empty: [int] = [];
    assert(empty.len == 0, "empty slice len != 0");
}
